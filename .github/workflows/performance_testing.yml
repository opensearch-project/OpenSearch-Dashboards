name: Performance Testing

on:
  pull_request:
    branches:
      - main
permissions:
  contents: read
  pull-requests: write
  statuses: write

env:
  NODE_OPTIONS: '--max-old-space-size=6144 --dns-result-order=ipv4first'
  LATEST_VERSION: '2.17.0'

jobs:
  lighthouse:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Setup Node
        uses: actions/setup-node@v2
        with:
          node-version-file: '.nvmrc'
          registry-url: 'https://registry.npmjs.org'

      - name: Setup Yarn
        run: |
          npm uninstall -g yarn
          npm i -g yarn@1.22.10

      - name: Run bootstrap
        run: yarn osd bootstrap

      - name: Download OpenSearch
        uses: suisei-cn/actions-download-file@v1.4.0
        with:
          url: https://artifacts.opensearch.org/releases/bundle/opensearch/${{ env.LATEST_VERSION }}/opensearch-${{ env.LATEST_VERSION }}-linux-x64.tar.gz

      - name: Extract OpenSearch
        run: |
          tar -xzf opensearch-*.tar.gz
          rm -f opensearch-*.tar.gz
        shell: bash

      - name: Remove security plugin
        run: |
          /bin/bash -c "yes | ./opensearch-${{ env.LATEST_VERSION }}/bin/opensearch-plugin remove opensearch-security"
        shell: bash

      - name: Run OpenSearch
        run: |
          /bin/bash -c "./opensearch-${{ env.LATEST_VERSION }}/opensearch-tar-install.sh &"
          sleep 30
        shell: bash

      - name: Install Lighthouse CI
        run: yarn add --dev @lhci/cli

      - name: Run bootstrap
        run: yarn osd bootstrap

      - name: Build plugins
        run: node scripts/build_opensearch_dashboards_platform_plugins --no-examples --workers 12

      - name: Wait for OpenSearch to be ready
        run: |
          until curl -s http://localhost:9200 >/dev/null; do
            echo "Waiting for OpenSearch..."
            sleep 10
          done
          echo "OpenSearch is up!"

      - name: Start OpenSearch Dashboards
        run: |
          yarn start --no-base-path &
          until curl -s http://localhost:5601 >/dev/null; do
            echo "Waiting for OpenSearch Dashboards..."
            sleep 10
          done
          echo "OpenSearch Dashboards is up!"

      - name: Mock data
        run: |
          curl 'http://localhost:5601/api/sample_data/ecommerce' -X 'POST' -H 'osd-version: 3.0.0' -H 'osd-xsrf: osd-fetch'

      # - name: Run Lighthouse CI
      #   run: |
      #     export LHCI_GITHUB_APP_TOKEN=${{ secrets.GITHUB_TOKEN }}
      #     yarn lhci autorun --verbose || echo "Lighthouse assertion failed, check results"
      #   env:
      #     LHCI_GITHUB_APP_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Run Lighthouse CI
        run: |
          export GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}
          yarn lhci autorun --verbose | tee lhci_output.txt
        continue-on-error: true

      - name: Verify Lighthouse Results
        run: |
          if [ ! -d ".lighthouseci" ] || [ -z "$(ls -A .lighthouseci)" ]; then
            echo "‚ùå Lighthouse CI did not generate reports."
            exit 1
          fi

      - name: Post Lighthouse Results into comment
        run: |
          # Validate if empty
          if [ ! -s .lighthouseci/assertion-results.json ]; then
            echo "‚ùå No assertion results found. Skipping PR comment."
            exit 0   #Prevents failure
          fi

          # Ensure JSON is properly formatted
          if ! jq empty .lighthouseci/assertion-results.json; then
            echo "‚ùå Invalid JSON format in Lighthouse assertion results."
            cat .lighthouseci/assertion-results.json  # Print for debugging
            exit 1
          fi

          # Extract failed assertions
          FAILURES=$(jq -r '[.[] | select(.passed==false) | {metric: .auditId, reason: .auditTitle, url: .url}]' .lighthouseci/assertion-results.json)

          REPORT_URLS=$(grep -Eo 'https://storage.googleapis.com[^ ]+' lhci_output.txt)

          REPORT_URLS_ARRAY=$(echo "$REPORT_URLS" | tr ' ' '\n' | jq -R . | jq -s .)

          UNIQUE_FAILURE_URLS=$(echo "$FAILURES" | jq '[.[] | .url] | unique')

          # Map URLs to reports
            URL_REPORT_MAP=$(jq -n --argjson failures "$UNIQUE_FAILURE_URLS" --argjson report_urls "$REPORT_URLS_ARRAY" '
              reduce range(0; ($failures | length)) as $i (
                {};
                if $i < ($report_urls | length) then
                  .[$failures[$i]] = $report_urls[$i]
                else
                  .[$failures[$i]] = null
                end
              )
            ')

          # Append report URLs to failed assertions
          FAILURES_WITH_REPORTS=$(jq --argjson url_report_map "$URL_REPORT_MAP" '
            map(. + {reportUrl: $url_report_map[.url]})
          ' <<< "$FAILURES")

          # Format PR comment
          if [[ "$FAILURES_WITH_REPORTS" == "[]" ]]; then
            echo "‚úÖ **All Lighthouse metrics passed!** üéâ" > comment.txt
          else
            echo "$FAILURES_WITH_REPORTS" | jq -r '.[] | "| \(.metric) | \(.reason) | \(.url) | [Report](\(.reportUrl)) |"' >> comment.txt
          fi

          # Post comment on PR
          gh pr comment ${{ github.event.pull_request.number }} --body "$(cat comment.txt)"
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{  secrets.GITHUB_TOKEN  }}

      - name: Cleanup Lighthouse Reports
        run: rm -f .lhci_output.txt && rm -rf .lighthouseci
